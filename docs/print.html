<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blue Engine</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The official documentation of the Blue Engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="first_chapter/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_chapter/setup.html"><strong aria-hidden="true">1.1.</strong> Installation and first look</a></li><li class="chapter-item expanded "><a href="first_chapter/philosophy.html"><strong aria-hidden="true">1.2.</strong> Philosophy, structure, and technologies</a></li><li class="chapter-item expanded "><a href="first_chapter/hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="second_chapter/introduction.html"><strong aria-hidden="true">2.</strong> Engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second_chapter/renderer.html"><strong aria-hidden="true">2.1.</strong> Renderer</a></li><li class="chapter-item expanded "><a href="second_chapter/window.html"><strong aria-hidden="true">2.2.</strong> Window</a></li><li class="chapter-item expanded "><a href="second_chapter/objects.html"><strong aria-hidden="true">2.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="second_chapter/camera.html"><strong aria-hidden="true">2.4.</strong> Camera</a></li></ol></li><li class="chapter-item expanded "><a href="third_chapter/introduction.html"><strong aria-hidden="true">3.</strong> Examples</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Blue Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Here lives the guide for the <a href="https://github.com/ElhamAryanpur/BlueEngine">Blue Engine</a>, including examples, tips, tricks, philosophy, and more.</p>
<p>The early idea for this project was to use this engine as the first layer for all future projects of myself, but later was decided that it should be made for general use. Now the engine can be used for games, GUIs, or even as a render backend.</p>
<p>Although the engine is quite young in terms of development, the main focus is stability, flexibility, ease of use, and portability.</p>
<p>We do have a small community as of now, mainly on <a href="https://discord.gg/s7xsj9q">discord</a>. So join us if you haven't yet!.</p>
<hr />
<p>The engine is licensed under Apache-2.0 license and includes all the files in this repository, unless stated otherwise.</p>
<p>Edit this guide on the <a href="https://github.com/ElhamAryanpur/BlueEngineDocs">Blue Engine Doc</a> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>To start, we need to setup the framework first. This guide expects you to know basics of Rust. If not, start <a href="https://rust-lang.org">here</a></p>
<p>Fortunately, the installation is very simple; thanks to rust's ecosystem. Because we're using Rust, make sure you have it <a href="https://www.rust-lang.org/tools/install">installed</a> and working properly along <code>cargo</code>.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>If you'd like to try testing the engine before starting to work with it, you'd need to download/clone the repository.</p>
<pre><code class="language-bash">git clone https://github.com/ElhamAryanpur/BlueEngine

cd BlueEngine 
</code></pre>
<p>After that, you can try running examples that are currently provided. For example, let's try running Triangle example that shows a white-ish triangle on your screen:</p>
<pre><code class="language-bash">cargo run --example triangle
</code></pre>
<p>Cargo will download dependencies, setup the engine, and run the example. After it's all done, a window will appear with the triangle in middle. If you can't see a triangle, make sure that your drivers are up-to-date. If any errors were shown on console and you think might be source of the problem, feel free to <a href="https://github.com/ElhamAryanpur/BlueEngine/issues">open a new issue</a> and I'll look into it.</p>
<p>The <a href="https://github.com/ElhamAryanpur/BlueEngine/tree/master/examples">examples</a> folder provides valuable source of examples on how the engine can be used. More examples will be added as the time goes. Although the API is unstable now, the examples keep up with the latest API changes.</p>
<h2 id="new-blue-engine-project"><a class="header" href="#new-blue-engine-project">New Blue Engine project</a></h2>
<p>To start a new Blue Engine project, open your command line in the desired folder, and create a new project with cargo:</p>
<pre><code class="language-bash">cargo init my_awesome_be_project
</code></pre>
<p>Make sure to replace <code>my_awesome_be_project</code> with your desired name, or, just leave it with that, we know it'll be awesome either way :D</p>
<p>After that, add this as dependency in your <code>Cargo.toml</code> in the project folder:</p>
<pre><code class="language-toml"># The star tells the package manager to download the latest version
blue_engine = &quot;*&quot;
</code></pre>
<p>If you want a specific version, you can specify it too! E.g. the current published version as of this writing:</p>
<pre><code class="language-toml">blue_engine = &quot;0.3.7&quot;
</code></pre>
<p>If you'd like to enable an optional feature, you can specify it in the <code>features</code> list:</p>
<pre><code class="language-toml"># For example enable gui support
blue_engine = { version = &quot;*&quot;, features = [&quot;gui&quot;] }
</code></pre>
<p>That's it! Just open the <code>main.rs</code> file in the <code>src</code> folder and make the world a better place!</p>
<h2 id="turbo-build-times"><a class="header" href="#turbo-build-times">Turbo build times</a></h2>
<p>This will allow fast build times on debug. This works by building a shared library/dynamic library and linking it with executable. Rust's compiler spends quite some time to pack and link everything into an exectuable on each build, so this will remove the need to repack and link the engine, thus improving the build times significantly. There are a few steps to follow, but they're not hard.</p>
<blockquote>
<p><code>DO NOT USE FOR FINAL RELEASE! OR ELSE WILL NEED TO COPY EXTRA FILES ALONG YOUR EXECUTABLE.</code></p>
</blockquote>
<h3 id="clone-the-engine"><a class="header" href="#clone-the-engine">Clone the engine</a></h3>
<p>We first start by cloning the engine from github. Move to parent directory of your project, and clone the engine:</p>
<pre><code class="language-bash">git clone https://github.com/ElhamAryanpur/BlueEngine
</code></pre>
<p>Your project structure should look something like this:</p>
<pre><code class="language-bash">Projects:
    - blue_engine
    - my_app
</code></pre>
<p>With <code>my_app</code> being your project. This way it ensures you can use it for multiple projects at once too as it's a one-time setup.</p>
<h3 id="setup-the-engine"><a class="header" href="#setup-the-engine">Setup the engine</a></h3>
<p>Open the engine's folder, and add this to the <code>Cargo.toml</code> under <code>[lib]</code>.</p>
<pre><code class="language-toml">crate-type = [&quot;dylib&quot;]
</code></pre>
<p>This essentially tells the compiler to compile the engine as a shared library/dynamic library, after finishing the setup, in the build folder you should be able to see a file with similar name to <code>libblue_engine</code>.</p>
<h3 id="setup-your-project"><a class="header" href="#setup-your-project">Setup your project</a></h3>
<p>And on your project's <code>Cargo.toml</code> under <code>[dependencies]</code>, add <code>path = &quot;../blue_engine&quot;</code> to the <code>blue_engine</code> as such:</p>
<pre><code class="language-toml">blue_engine = { path = &quot;../blue_engine&quot;, .. } # replace the .. with the rest. e.g. version, features, e.t.c.
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>For windows, you need to go one more step. This essentially doesn't work normally, hence you'll need to add some more configuration and switch to nightly.</p>
<p>Switch to nightly:</p>
<pre><code class="language-bash">rustup override set nightly
</code></pre>
<p>This sets current project to nightly only. And next step is in your project's directory, add a folder with the name <code>.cargo</code>, and add a file in it with the name <code>config.toml</code> and copy these into it:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = &quot;rust-lld.exe&quot;
rustflags = [&quot;-Zshare-generics=off&quot;]
</code></pre>
<h3 id="enjoy-fast-builds"><a class="header" href="#enjoy-fast-builds">Enjoy fast builds</a></h3>
<p>And that's it! You should now see faster build times. For final release versions, make sure to just remove <code>path = &quot;../blue_engine&quot;</code> from dependency, and you should be good to go for release. You can also configure it in <code>Cargo.toml</code> to use the path for debug profile and non turbo build for release profile as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="philosophy-structure-and-technologies"><a class="header" href="#philosophy-structure-and-technologies">Philosophy, structure, and technologies</a></h1>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>The philosophy is always to bring as much ease of use and flexibility as possible. Anything done with the engine, the changes made, the features added, e.t.c. are all made to be as easy-to-use and as flexible as possible for everyone to have a peace of mind when using. Doing graphics shouldn't be hard even at such low level right?</p>
<p>For most people, use cases differ. And because of that, the level of abstraction should differ too; the engine must be flexible enough to accommodate that. This is how Blue Engine can be as high or low level when using as you need. Just need objects to be displayed? Sure thing, they're just one line away! Want to have custom built structure for your own shape and bring your custom engines upon it with custom shaders, textures, and more? We got you covered too! There's something for everyone!</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The source code is structured to have a common place for every part of the engine. I took a bit of idea from structures of C/C++ projects for organizing the source code. And came up with a similar organizational structure.</p>
<ul>
<li>
<p>all the <code>structs</code>, <code>types</code>, <code>enums</code>, e.t.c. are all under <code>header.rs</code> file. This file also specify if a part will be public for other crate use or not as well as global default data, such as default texture, default shader, and more.</p>
</li>
<li>
<p>Methods' code and implementation live under their designated file. The target classes will be taken from the definitions file.</p>
</li>
<li>
<p>Methods' code and other parts like camera, window, render, e.t.c. will each have their own files for custom and clean progress and to not interfere with each-other.</p>
</li>
</ul>
<h2 id="technologies-used"><a class="header" href="#technologies-used">Technologies used</a></h2>
<p>I try to use standard library as much as possible, but some parts are too much to write, or not possible within the bounds of standard library such as windowing, rendering APIs, e.t.c. For these, I use crates that already provide those. Even if a need for an external crate rises, I try as much as possible to ensure cross-platform portability, ease of use, and keep it as lightweight as possible, and to not be a roadblock for development and use.</p>
<p>The technologies used as of now, can be viewed on the <code>cargo.toml</code> file in the root directory under <code>dependencies</code> section.</p>
<h2 id="dependency-justification-as-of-037"><a class="header" href="#dependency-justification-as-of-037">Dependency justification as of 0.3.7</a></h2>
<ul>
<li>
<p><code>futures = &quot;0.3.21&quot;</code>: is used for blocking the async functions that is used internally in lower level apis.</p>
</li>
<li>
<p><code>winit = &quot;0.26.1&quot;</code>: handles the creation and control of windows and contexts.</p>
</li>
<li>
<p><code>image = &quot;0.24.2&quot;</code>: used for texture reading and handling of images.</p>
</li>
<li>
<p><code>bytemuck = { version = &quot;1.10.0&quot;, features = [&quot;derive&quot;] }</code>: small utilities for casting between plain data types. Helps with sending bytes to gpu.</p>
</li>
<li>
<p><code>winit_input_helper = &quot;0.12.0&quot;</code>: helps with gathering input event data, and leaving an easy-to-use list of functions to access them. It's more of a quality-of-life dependency.</p>
</li>
<li>
<p><code>anyhow = &quot;1.0.57&quot;</code>: helps with error handling.</p>
</li>
<li>
<p><code>env_logger = &quot;0.9.0&quot;</code>: Logs internal events, and gives useful error and logs. Very good for debugging!</p>
</li>
<li>
<p><code>wgpu = { version = &quot;0.13.0&quot; }</code>: a wrapper over graphics api, based on WebGPU standard. Very awesome api for rendering graphics that just makes sense! It also helps with having your graphic run everywhere optimally.</p>
</li>
<li>
<p><code>nalgebra-glm = &quot;0.17.0&quot;</code>: math library for all the math that is used in the engine.</p>
</li>
</ul>
<hr />
<p>These are optional dependencies that are enabled with flags:</p>
<ul>
<li>
<p><code>gltf = { version = &quot;1.0.0&quot;, optional = true }</code>: used for handling gltf 2.0 and glb files. Enabled with <code>model_loader</code> feature flag.</p>
</li>
<li>
<p><code>imgui-wgpu = { version = &quot;0.20.0&quot;, optional = true }</code>, <code>imgui-winit-support = { version = &quot;0.8.2&quot;, optional = true, features = [ &quot;winit-26&quot;, ] }</code>, and <code>imgui = { version = &quot;0.8.2&quot;, optional = true }</code>: are used for GUI (Graphical User Interface), uses industry-proven c++ imgui library. This can be enabled with <code>gui</code> feature flag.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h2>
<p>Firstly let's create a new rust project:</p>
<pre><code class="language-bash">cargo init --bin blue_graphics
</code></pre>
<p>After that's taken care of, open <code>cargo.toml</code> and add the crate under dependencies:</p>
<pre><code class="language-toml">[dependencies]
blue_engine = &quot;*&quot;
</code></pre>
<p>This should now install Blue Engine and all it's dependencies. We should be ready to get started.</p>
<h2 id="engine-initialization"><a class="header" href="#engine-initialization">Engine initialization</a></h2>
<p>Alright, now that we're done with that, let's get the exciting work started! Firstly, we will create a new window so that later we can draw under it!</p>
<p>Firstly, open the <code>main.rs</code> file under <code>src</code> folder, and paste below in it:</p>
<pre><pre class="playground"><code class="language-rust">use blue_engine::header::{Engine, WindowDescriptor};         // 0

fn main(){
  let mut engine = Engine::new(WindowDescriptor::default())  // 1
    .expect(&quot;Couldn't init the Engine&quot;);                     // 2

    engine
        .update_loop(move |_, _, _, _, _| {})                // 3, 4
        .expect(&quot;Error during update loop&quot;);                 // 5
}
</code></pre></pre>
<ol start="0">
<li>We need some structs to initialize the engine.</li>
<li>We initialize the Engine and start to describe how the window should look like. For now, we'll use the default values.</li>
<li>The initialization returns a <code>Result&lt;Engine&gt;</code> which you can unwrap. This way you can also check if there is any error during the creation of the Engine.</li>
<li>The update loop is responsible for everything that you will do that needs to be updated or checked every frame. This includes checking for events such as inputs, or updating certain things if a change happens.</li>
<li>The _ are to not use the parameters passed on. The update loop gives you access to 5 things in this order:
<ol>
<li>renderer</li>
<li>window</li>
<li>objects</li>
<li>events</li>
<li>camera</li>
</ol>
</li>
<li>Update loop also returns a <code>Result&lt;()&gt;</code>. The errors that will happen through this means something during the update loop. So make sure to check for errors during the update loop as well, or not if you're a brave soul :)</li>
</ol>
<p>After you're done, you can run:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should now see an empty window! Congratulations you just created your first window using Blue Engine!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine-introduction"><a class="header" href="#engine-introduction">Engine introduction</a></h1>
<h2 id="engine"><a class="header" href="#engine">Engine</a></h2>
<p><code>Engine</code> is the starting point for using the BE (Blue Engine). It acts like a tree, with each branch being a functionality. This is an opinionated approach and not often liked by all of Rust's community as it brings up some issues for the borrow checker. However  it appears to be working for our case, so unless highly requested or a major issue appears it will remain in such way. In future the monolithic structure will be changed with modular approach, but as of current versions, it will remain as such.</p>
<p>The <code>Engine</code> is a <code>struct</code> type, and contains:</p>
<ul>
<li><code>Renderer</code></li>
<li><code>Window</code></li>
<li><code>Objects</code></li>
<li><code>Camera</code></li>
<li><code>event_loop</code> [hidden to create only]</li>
</ul>
<p>We will discuss each of them in great detail later on. For now, let's look at an example on how to start using the <code>Engine</code>.</p>
<pre><pre class="playground"><code class="language-rust">// import the Engine and WindowDescriptor from the header.
use blue_engine::header::{Engine, WindowDescriptor};

fn main() {
    // you can create the engine through the Engine::new()
    // it returns a Result&lt;Engine&gt;
    let engine = Engine::new(WindowDescriptor::default()).expect(&quot;Couldn't create the engine&quot;);
}
</code></pre></pre>
<p><code>WindowDescriptor</code> is used for window settings as the <code>Engine</code> initializes it too. The <code>WindowDescriptor</code> has these default values:</p>
<table><thead><tr><th>Parameter</th><th>value</th></tr></thead><tbody>
<tr><td>width</td><td>800</td></tr>
<tr><td>height</td><td>600</td></tr>
<tr><td>title</td><td>Blue Engine</td></tr>
<tr><td>decorations</td><td>true</td></tr>
<tr><td>resizable</td><td>true</td></tr>
</tbody></table>
<p>You can also alter only few and leave the rest as default.</p>
<p>After you initialized the engine, you can start the update loop. The update loop runs code per frame, and also provides events and updates.</p>
<blockquote>
<p>note that the events are updated BEFORE each frame! So any changes you make in this frame, will be updated on the next frame.</p>
</blockquote>
<h2 id="update-loop"><a class="header" href="#update-loop">Update loop</a></h2>
<p>The update loop is method of <code>Engine</code> that has one parameter which is a mutable callback function, that provides these:</p>
<ul>
<li><code>&amp;mut Renderer</code></li>
<li><code>&amp;Window</code></li>
<li><code>&amp;mut Vec&lt;Object&gt;</code></li>
<li><code>&amp;Input</code></li>
<li><code>&amp;mut Camera</code></li>
</ul>
<p>The fields that are not mutable are only there to provide information. The mutable fields are the ones where your changes will exist, such as showing things on screen, moving camera, e.t.c.</p>
<p>Once you run the update_loop, the window will start to appear. You can also leave the loop empty for an empty screen! The loop also allows to use the <code>move</code> keyword before for passing variables from outside the scope to the inside of the loop.</p>
<p>Creating an update loop that's empty is as easy as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the underscores shows that we do not want to use them now.
// The `move` keyword makes it possible to use variables from outside of the loop scope.
engine.update_loop(move |_, _, _, _, _| {})
        .expect(&quot;Error during update loop&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This function returns a <code>Result&lt;()&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renderer"><a class="header" href="#renderer">Renderer</a></h1>
<p>Let's talk about the renderer. <code>Renderer</code> handles everything that is about talking with the GPU to render things you specify. This includes</p>
<ul>
<li>Shaders</li>
<li>Textures</li>
<li>Vertices</li>
<li>Uniform Buffers</li>
</ul>
<p>We'll discuss more about each of them later on, for now let's talk about how it looks like and how it works.</p>
<p>There are default data of them except for vertices. The exist on the 0th index. Which includes a default uniform buffer (transformation, camera and color), a default texture (one white pixel), and a default shader. We'll talk about them later on.</p>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<p>The Pipeline is the way that BE handles data to renderer. BE stores data for rendering on a dynamically sized array and gives you their index on time of creation. A <code>Pipeline</code> struct holds one index for each of those four things listed above. At time of render, the values are then fetched from the array and sent to GPU. We will learn about the order and position of each of them when rendering, later. For now, think of pipeline as the data holder of your object.</p>
<h2 id="shader"><a class="header" href="#shader">Shader</a></h2>
<p>Shaders are programs that run in the GPU. BE uses <a href="https://www.w3.org/TR/WGSL/">WGSL</a> which is the main shading language of WebGPU.</p>
<p>As of yet, only vertex and fragment stages are supported. You can also change many other aspects such as cull face, render mode, and more at the time of shader creation!</p>
<p>You can change those settings through the <code>ShaderSetting</code>, and of course default settings also exist. They are:</p>
<table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>topology</td><td>TriangleList</td></tr>
<tr><td>strip_index_format</td><td>None</td></tr>
<tr><td>front_face</td><td>Ccw</td></tr>
<tr><td>cull_mode</td><td>Back</td></tr>
<tr><td>polygon_mode</td><td>Fill</td></tr>
<tr><td>clamp_depth</td><td>false</td></tr>
<tr><td>conservative</td><td>false</td></tr>
<tr><td>count</td><td>1</td></tr>
<tr><td>mask</td><td>!0</td></tr>
<tr><td>alpha_to_coverage_enabled</td><td>false</td></tr>
</tbody></table>
<p>To create a new shader through BE and append it to the storage for render, you can use the <code>build_and_append_shader()</code>.</p>
<blockquote>
<p>The shader source as of yet (0.2.5) only supports WGSL, but later on the support for SPIR-V compiled shaders will also be available.</p>
</blockquote>
<h2 id="textures"><a class="header" href="#textures">Textures</a></h2>
<p>Textures are images that can be burned to vertices on the scene. They have all sorts of uses, e.g. adding textures to plane to make it look like a wall or ground, or textures to character shapes for more details.</p>
<p>As of now (0.2.5), BE only supports RGBA based textures. PNG is the recommended file format and the format is Rgba8UnormSrgb.</p>
<p>There's two ways to create BE textures</p>
<ol>
<li>Creating an <code>image::DynamicImage</code> and appending that</li>
<li>Using bytes of the image and creating one.</li>
</ol>
<p><code>image</code> is a rust crate that BE uses under the hood for processing texture data.</p>
<p>BE also allows for different modes of the texture in case the texture couldn't fit, which are:</p>
<ul>
<li>Clamp</li>
<li>Repeat</li>
<li>Mirror repeat</li>
</ul>
<p>The textures are sampled as well, and they can be accessed on group 0 on slot:</p>
<ol start="0">
<li>Texture</li>
<li>Sampler</li>
</ol>
<h2 id="vertices"><a class="header" href="#vertices">Vertices</a></h2>
<p>A <code>Vertex</code> in BE is a point in 3D space that also includes the positions of texture associated with it.</p>
<p>Vertices in BE exist with their indices to create shapes and reuse vertex data. And by default they're rendered in counter clockwise manner and in triangle form.</p>
<p>There are no settings for vertices. You can access vertex position [vector3] at location 0, and the associated texture coordination [vector2] at location 1 in the vertex shader. And you can output the texture coordinates to fragment shader at location 0.</p>
<h2 id="uniform-buffers"><a class="header" href="#uniform-buffers">Uniform Buffers</a></h2>
<p>Uniform buffers are small bits of custom data sent to the GPU. BE supports 3 default types of Uniform Buffers:</p>
<ul>
<li>Float32</li>
<li>Vector4 of Float32</li>
<li>Matrix4x4 of Float32</li>
</ul>
<p>You can also define a custom Uniform Buffer structure, just make sure to implement <code>Pod</code> and <code>Zeroable</code> traits, along <code>C</code> layout.</p>
<p>Many uniform buffers can be sent at one time, and the order that you send them matters. You can access them on group 2 and the slot is in the order you specify.</p>
<p>By default the starting would be conditional. If you disable camera, it'll start at 1, elsewise will start at 2. as the 0th slot is for transformation matrix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windowing-input"><a class="header" href="#windowing-input">Windowing, input</a></h1>
<p>Windowing in Blue Engine is handled by <a href="https://github.com/rust-windowing/winit">winit</a>, and the events are handled by <a href="https://github.com/rukai/winit_input_helper">winit input helper</a>. In the future SDL2 is an alternative planned implementation, but as of now winit handles all the windowing needs.</p>
<h2 id="window-settings"><a class="header" href="#window-settings">Window settings</a></h2>
<p>The window has a bunch of settings that can be changed and manipulated. These window settings are applied at the time of engine initialization. The settings exist as <code>WindowDescriptor</code> and the options and their default data are as such:</p>
<table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>width</td><td>800</td></tr>
<tr><td>height</td><td>600</td></tr>
<tr><td>title</td><td>&quot;Blue Engine&quot;</td></tr>
<tr><td>decorations</td><td>true</td></tr>
<tr><td>resizable</td><td>true</td></tr>
</tbody></table>
<ul>
<li>
<p>Decorations are the title bar and the borders that windows have. Setting it to false will remove them, which is also called borderless windowing.</p>
</li>
<li>
<p>Resizable is a setting that allows the windows to be resized or stay in a fixed size. Having this set to false will also disable maximize and minimize options.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-objects"><a class="header" href="#what-are-objects">What are objects?</a></h1>
<p>An object in Blue Engine is a collection of a vertex buffer, shader, texture, and maybe a uniform buffer, and allows various operations on them such as scaling, translation, change in data, and more. Objects are similar to nodes in Godot. Other traits can be applied to them to add extra functionalities that are desired. Objects are the only things are are sent for render and they are the very basic element of Blue Engine. Unlike the many structures that exist so far, objects do not have a parent or a child, and does not work in a tree structure. Instead the objects are stored in a dynamically sized array which then are iterated upon when rendering.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>A new object can be created by using the engine's <code>new_object</code> method. Three arguments are required:</p>
<ul>
<li>Vertices: a <code>Vec&lt;Vertex&gt;</code> which includes the vertices for your object.</li>
<li>Indices: a <code>Vec&lt;u16&gt;</code> which includes the indices of your vertices.</li>
<li><code>ObjectSettings</code> which is a struct defining the structure and settings for the object. These can later on be changed as well. The list of options along their default values are as such:</li>
</ul>
<table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>name</td><td>Some(&quot;Object!&quot;)</td></tr>
<tr><td>size</td><td>(100f32, 100f32, 100f32)</td></tr>
<tr><td>scale</td><td>(1f32, 1f32, 1f32)</td></tr>
<tr><td>position</td><td>(0f32, 0f32, 0f32)</td></tr>
<tr><td>color:</td><td>uniform_type::Array [DEFAULT_COLOR]</td></tr>
<tr><td>camera_effect</td><td>true</td></tr>
<tr><td>shader_settings</td><td>ShaderSettings::default()</td></tr>
</tbody></table>
<ul>
<li>color's uniform type of array is due to the color being passed down to the uniform buffer and applied at fragment stage.</li>
<li>camera effect defines if the camera transformations have any effect on the object. An object with camera effect as false will not experience any move from camera unless manually moved, and also will not be affected by POV change or anything else related to cameras.</li>
<li>shader settings are a collection of settings related to the shaders, their options and default values are defined in the renderer page of this guide.</li>
</ul>
<p>Upon creation, an <code>&amp;mut Object</code> will be returned wrapped in <code>Result</code>. Which then you can further change and update.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera"><a class="header" href="#camera">Camera</a></h1>
<p>Camera in Blue Engine is default initialized upon creation. This may change in the future, but as of yet a default camera is created. This camera is left-hand perspective camera, and some default values are assigned according to the window which are as such:</p>
<table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>position</td><td>(0f32, 0f32, 1f32)</td></tr>
<tr><td>target</td><td>(0f32, 0f32, 0f32)</td></tr>
<tr><td>up</td><td>(0f32, 1f32, 0f32)</td></tr>
<tr><td>aspect</td><td>window_width / window_height</td></tr>
<tr><td>fov</td><td>70f32 * (PI / 180f32)</td></tr>
<tr><td>near</td><td>0.1f32</td></tr>
<tr><td>far</td><td>100f32</td></tr>
<tr><td>view_data</td><td>DEFAULT_MATRIX_4</td></tr>
</tbody></table>
<ul>
<li>position, target, and up defines how the camera views the scene, changing these parameters allow you to alter the view.</li>
<li>fov is in radians instead of degrees.</li>
<li>near and far define how close and how far can the camera sees, changing these values will alter how much further or near are things in your scene visible.</li>
<li>view data is a matrix containing the matrix that will be applied to the scene during render, you usually don't have to deal with this directly.</li>
</ul>
<p>Along with these options, you can alter the parameters through methods that are assigned. For example <code>set_position</code> to change the position of the camera in the scene. Each of these methods start with <code>set_</code> and then the option name, e.g. <code>set_fov</code> or <code>set_far</code>.</p>
<p>More options and features will be added as time goes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-projects"><a class="header" href="#example-projects">Example projects</a></h1>
<p>Let's make an example project, we'll start from the basics and go deep as time goes.</p>
<p>In the end you'll learn how to:</p>
<ul>
<li>
<p>create window and modify it</p>
</li>
<li>
<p>add objects to the scene</p>
</li>
<li>
<p>modify objects and give them movement</p>
</li>
<li>
<p>add many objects and move all of them</p>
</li>
<li>
<p>add gui (use optional featues in the engine)</p>
</li>
<li>
<p>interop gui with the scene</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
